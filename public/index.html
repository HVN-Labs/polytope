<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway-Hart Polyhedron Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #333;
            margin-bottom: 15px;
            font-size: 24px;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="text"] {
            padding: 10px 15px;
            border: 2px solid #667eea;
            border-radius: 5px;
            font-size: 16px;
            width: 200px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #764ba2;
        }

        button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #764ba2;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        button.active {
            background: #e74c3c;
        }

        button.active:hover {
            background: #c0392b;
        }

        .toggle-group {
            display: flex;
            gap: 5px;
            background: #f0f0f0;
            padding: 5px;
            border-radius: 5px;
        }

        .toggle-group button {
            padding: 8px 15px;
            font-size: 14px;
            background: white;
            color: #666;
        }

        .toggle-group button.active {
            background: #667eea;
            color: white;
        }

        .mode-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(231, 76, 60, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            display: none;
            z-index: 100;
        }

        .mode-indicator.active {
            display: block;
        }

        .examples {
            color: #666;
            font-size: 14px;
            margin-top: 10px;
        }

        .examples span {
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            padding: 2px 5px;
            border-radius: 3px;
            transition: background 0.3s;
        }

        .examples span:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .container {
            flex: 1;
            display: flex;
            gap: 0;
            overflow: hidden;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        .info-panel {
            width: 350px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            overflow-y: auto;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
        }

        .info-panel h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-section h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        .stat-label {
            color: #666;
        }

        .stat-value {
            color: #333;
            font-weight: bold;
        }

        .vertices-list {
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
        }

        .vertex {
            padding: 3px 0;
            color: #333;
        }

        .error {
            color: #e74c3c;
            padding: 10px;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .legend {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            font-size: 13px;
            color: #666;
            line-height: 1.6;
        }

        .legend h4 {
            color: #667eea;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .legend code {
            background: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        /* Polygon Types Section */
        .polygon-types-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .polygon-type-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .polygon-canvas {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 5px;
            border: 1px solid #ddd;
            flex-shrink: 0;
        }

        .polygon-info {
            flex: 1;
            min-width: 0;
        }

        .polygon-name {
            font-weight: bold;
            color: #333;
            font-size: 14px;
        }

        .polygon-count {
            color: #666;
            font-size: 12px;
        }

        .polygon-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .remove-polygon-btn {
            padding: 5px 8px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            white-space: nowrap;
        }

        .remove-polygon-btn:hover {
            background: #c0392b;
        }

        .remove-polygon-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .remove-half-btn {
            padding: 5px 8px;
            background: #f39c12;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            white-space: nowrap;
        }

        .remove-half-btn:hover {
            background: #d68910;
        }

        .remove-half-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Animate Panel */
        .animate-panel {
            display: none;
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 200;
            width: 320px;
            max-height: calc(100% - 40px);
            overflow-y: auto;
        }

        .animate-panel.active {
            display: block;
        }

        .animate-panel-content {
            padding: 15px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 2px solid #9b59b6;
            padding-bottom: 10px;
        }

        .panel-header h3 {
            margin: 0;
            color: #333;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            line-height: 1;
        }

        .close-btn:hover {
            color: #333;
        }

        .settings-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .settings-section h4 {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 13px;
        }

        .animation-section {
            margin-bottom: 15px;
            padding: 12px;
            background: #f8f8f8;
            border-radius: 8px;
        }

        .animation-section h4 {
            margin: 0 0 10px 0;
            color: #9b59b6;
            font-size: 14px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .setting-row label {
            color: #555;
            font-size: 13px;
        }

        .setting-row span {
            color: #888;
            font-size: 12px;
        }

        .setting-row input[type="number"] {
            padding: 5px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
        }

        .button-row {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .play-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            flex: 1;
        }

        .play-btn:hover {
            background: #219a52;
        }

        .stop-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }

        .stop-btn:hover:not(:disabled) {
            background: #c0392b;
        }

        .stop-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .export-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }

        .export-btn:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Conway-Hart Polyhedron Viewer</h1>
        <div class="controls">
            <div class="input-group">
                <label for="notation">Conway Notation:</label>
                <input type="text" id="notation" value="T" placeholder="e.g., T, C, dT, kC">
                <button id="generate">Generate</button>
            </div>
            <div class="input-group">
                <label for="z-scale">Vertical Scale:</label>
                <input type="range" id="z-scale" min="0.1" max="3" step="0.1" value="1" style="width: 150px;">
                <span id="z-scale-value">1.0</span>
            </div>
            <div class="toggle-group">
                <button id="view-vertices" class="active">Vertices Only</button>
                <button id="view-full">Full Polyhedron</button>
            </div>
            <button id="remove-polygon-mode">Remove Polygon</button>
            <button id="remove-vertex-mode">Remove Vertex</button>
            <button id="undo-vertex" disabled title="Undo (0/5)" style="background: #95a5a6;">Undo</button>
            <button id="redo-vertex" disabled title="Redo (0/5)" style="background: #95a5a6;">Redo</button>
            <button id="subdivide-edges" style="background: #3498db;">Subdivide Edges</button>
            <button id="animate-btn" style="background: #9b59b6;">Animate</button>
        </div>
        <div class="examples">
            <strong>Seeds:</strong>
            <span onclick="loadExample('T')">T</span>
            <span onclick="loadExample('C')">C</span>
            <span onclick="loadExample('O')">O</span>
            <span onclick="loadExample('D')">D</span>
            <span onclick="loadExample('I')">I</span>
            |
            <strong>Operators:</strong>
            <span onclick="loadExample('dC')">dC (dual)</span>
            <span onclick="loadExample('kC')">kC (kis)</span>
            <span onclick="loadExample('aD')">aD (ambo)</span>
            <span onclick="loadExample('gC')">gC (gyro)</span>
            <span onclick="loadExample('pC')">pC (propellor)</span>
            <span onclick="loadExample('tC')">tC (truncate)</span>
            <span onclick="loadExample('eC')">eC (explode)</span>
            <span onclick="loadExample('jC')">jC (join)</span>
            <span onclick="loadExample('sC')">sC (snub)</span>
            <span onclick="loadExample('cC')">cC (canonicalize)</span>
        </div>
    </div>

    <div class="container">
        <div id="canvas-container">
            <div class="loading" id="loading">Loading...</div>
            <div class="mode-indicator" id="mode-indicator">üéØ REMOVE POLYGON MODE - Click to remove | Drag to rotate</div>

            <!-- Animate Panel -->
            <div class="animate-panel" id="animate-panel">
                <div class="animate-panel-content">
                    <div class="panel-header">
                        <h3>Animations</h3>
                        <button id="close-animate-panel" class="close-btn">&times;</button>
                    </div>

                    <!-- Global Settings -->
                    <div class="settings-section">
                        <h4>Export Bounds</h4>
                        <div class="setting-row">
                            <label for="xy-min">XY:</label>
                            <input type="number" id="xy-min" value="-50" step="1" style="width:60px">
                            <span>to</span>
                            <input type="number" id="xy-max" value="50" step="1" style="width:60px">
                        </div>
                        <div class="setting-row">
                            <label for="z-min">Altitude:</label>
                            <input type="number" id="z-min" value="0" step="1" style="width:60px">
                            <span>to</span>
                            <input type="number" id="z-max" value="100" step="1" style="width:60px">
                        </div>
                        <div class="setting-row">
                            <label for="animation-duration">Duration (s):</label>
                            <input type="number" id="animation-duration" value="30" min="1" max="300" step="1" style="width:60px">
                        </div>
                    </div>

                    <!-- Rotate Animation -->
                    <div class="animation-section">
                        <h4>üîÑ Rotate</h4>
                        <div class="setting-row">
                            <label for="rotation-speed">Speed (m/s):</label>
                            <input type="number" id="rotation-speed" value="4" min="0.1" max="20" step="0.1" style="width:70px">
                        </div>
                        <div class="button-row">
                            <button id="play-rotate" class="play-btn">‚ñ∂ Play</button>
                            <button id="stop-rotate" class="stop-btn" disabled>‚ñ† Stop</button>
                            <button id="export-rotate" class="export-btn">Export .skyc</button>
                        </div>
                    </div>

                    <!-- Shrink Animation -->
                    <div class="animation-section">
                        <h4>üìè Shrink/Expand</h4>
                        <div class="setting-row">
                            <label for="scale-start">From:</label>
                            <input type="number" id="scale-start" value="1" min="0.01" max="5" step="0.1" style="width:60px">
                            <label for="scale-end">To:</label>
                            <input type="number" id="scale-end" value="0.1" min="0.01" max="5" step="0.1" style="width:60px">
                        </div>
                        <div class="setting-row">
                            <label for="shrink-speed">Speed (m/s):</label>
                            <input type="number" id="shrink-speed" value="2" min="0.1" max="20" step="0.1" style="width:70px">
                        </div>
                        <div class="button-row">
                            <button id="play-shrink" class="play-btn">‚ñ∂ Play</button>
                            <button id="stop-shrink" class="stop-btn" disabled>‚ñ† Stop</button>
                            <button id="export-shrink" class="export-btn">Export .skyc</button>
                        </div>
                    </div>

                    <!-- Combined Animation -->
                    <div class="animation-section">
                        <h4>üé¨ Combined (Rotate + Shrink)</h4>
                        <div class="button-row">
                            <button id="play-combined" class="play-btn">‚ñ∂ Play</button>
                            <button id="stop-combined" class="stop-btn" disabled>‚ñ† Stop</button>
                            <button id="export-combined" class="export-btn">Export .skyc</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="info-panel">
            <h2>Polyhedron Information</h2>
            <div id="info-content">
                <div class="info-section">
                    <div class="stat">
                        <span class="stat-label">Name:</span>
                        <span class="stat-value" id="poly-name">-</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Notation:</span>
                        <span class="stat-value" id="current-notation">-</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Vertices:</span>
                        <span class="stat-value" id="vertex-count">-</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Faces:</span>
                        <span class="stat-value" id="face-count">-</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Edges:</span>
                        <span class="stat-value" id="edge-count">-</span>
                    </div>
                </div>

                <div class="info-section">
                    <h3>Polygon Types</h3>
                    <div class="polygon-types-container" id="polygon-types-container">
                        <div style="color: #666; font-size: 13px;">No polyhedron loaded</div>
                    </div>
                </div>

                <div class="info-section">
                    <h3>Vertex Coordinates</h3>
                    <div class="vertices-list" id="vertices-list">
                        No polyhedron loaded
                    </div>
                </div>

                <div class="info-section">
                    <div class="legend">
                        <h4>Conway Notation Guide</h4>
                        <strong>Seeds:</strong><br>
                        <code>T</code>=Tetrahedron, <code>C</code>=Cube, <code>O</code>=Octahedron, <code>I</code>=Icosahedron, <code>D</code>=Dodecahedron<br>
                        <code>P[n]</code>=Prism, <code>A[n]</code>=Antiprism, <code>Y[n]</code>=Pyramid<br><br>
                        <strong>Basic Operators:</strong><br>
                        <code>d</code>=dual, <code>k</code>=kis, <code>a</code>=ambo, <code>g</code>=gyro, <code>p</code>=propellor<br>
                        <code>r</code>=reflect, <code>c</code>=canonicalize<br><br>
                        <strong>Compound Operators:</strong><br>
                        <code>e</code>=explode (aa), <code>b</code>=bevel (ta), <code>o</code>=ortho (jj)<br>
                        <code>m</code>=meta (kj), <code>t</code>=truncate (dkd), <code>j</code>=join (dad), <code>s</code>=snub (dgd)<br><br>
                        <strong>Examples:</strong><br>
                        <code>dC</code>=dual of cube, <code>kT</code>=kis tetrahedron, <code>tD</code>=truncated dodecahedron
                    </div>
                </div>

                <div id="error-message"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, polyhedronMesh, edgesMesh, raycaster, mouse;
        let currentPolyhedron = null;
        let currentNotation = '';
        let isDragging = false;
        let viewMode = 'vertices'; // 'vertices' or 'full'
        let removePolygonMode = false;
        let removeVertexMode = false;
        let faceObjects = []; // Store individual face meshes for raycasting
        let vertexSpheresGroup = null; // Group containing all vertex spheres
        let vertexSphereMap = new Map(); // Map vertex index to sphere mesh
        let zScale = 1.0; // Vertical scale factor

        // Undo/Redo history for vertex removal (max 5 entries)
        const MAX_HISTORY = 5;
        let undoStack = [];
        let redoStack = [];

        // Animation state
        let animationId = null;
        let animationStartTime = null;
        let originalVertices = null;
        let currentAnimationType = null;

        // Initialize Three.js scene
        function initScene() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);

            // Initialize raycaster for polygon selection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Mouse controls for rotation and selection
            let previousMousePosition = { x: 0, y: 0 };
            let mouseDownPos = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                mouseDownPos = { x: e.clientX, y: e.clientY };
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    if (polyhedronMesh) {
                        polyhedronMesh.rotation.y += deltaX * 0.01;
                        polyhedronMesh.rotation.x += deltaY * 0.01;
                    }

                    if (edgesMesh) {
                        edgesMesh.rotation.y += deltaX * 0.01;
                        edgesMesh.rotation.x += deltaY * 0.01;
                    }

                    // Rotate all face objects
                    faceObjects.forEach(obj => {
                        obj.rotation.y += deltaX * 0.01;
                        obj.rotation.x += deltaY * 0.01;
                    });

                    // Rotate vertex spheres group
                    if (vertexSpheresGroup) {
                        vertexSpheresGroup.rotation.y += deltaX * 0.01;
                        vertexSpheresGroup.rotation.x += deltaY * 0.01;
                    }

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }

                // Update hover effect in remove modes (only when not dragging)
                if (!isDragging && removePolygonMode && viewMode === 'full') {
                    updateMousePosition(e);
                    highlightHoveredFace();
                } else if (!isDragging && removeVertexMode) {
                    updateMousePosition(e);
                    highlightHoveredVertex();
                }
            });

            renderer.domElement.addEventListener('mouseup', (e) => {
                // Check if it was a click (not a drag)
                const dragDistance = Math.sqrt(
                    Math.pow(e.clientX - mouseDownPos.x, 2) +
                    Math.pow(e.clientY - mouseDownPos.y, 2)
                );

                if (dragDistance < 5 && removePolygonMode && viewMode === 'full') {
                    // It's a click in remove polygon mode
                    updateMousePosition(e);
                    handleFaceClick();
                } else if (dragDistance >= 5 && removePolygonMode && viewMode === 'full') {
                    // Was a drag in remove polygon mode, reset face colors
                    faceObjects.forEach(obj => {
                        obj.material.color.setHex(0x667eea);
                        obj.material.opacity = 0.7;
                    });
                } else if (dragDistance < 5 && removeVertexMode) {
                    // It's a click in remove vertex mode
                    updateMousePosition(e);
                    handleVertexClick();
                } else if (dragDistance >= 5 && removeVertexMode) {
                    // Was a drag in remove vertex mode, reset vertex colors
                    vertexSpheresGroup.children.forEach(sphere => {
                        sphere.material.color.setHex(0x667eea);
                        sphere.material.emissive.setHex(0x667eea);
                    });
                }

                isDragging = false;
            });

            renderer.domElement.addEventListener('mouseleave', () => {
                isDragging = false;

                // Reset face colors when mouse leaves in remove polygon mode
                if (removePolygonMode && viewMode === 'full') {
                    faceObjects.forEach(obj => {
                        obj.material.color.setHex(0x667eea);
                        obj.material.opacity = 0.7;
                    });
                    renderer.domElement.style.cursor = 'default';
                }

                // Reset vertex colors when mouse leaves in remove vertex mode
                if (removeVertexMode && vertexSpheresGroup) {
                    vertexSpheresGroup.children.forEach(sphere => {
                        sphere.material.color.setHex(0x667eea);
                        sphere.material.emissive.setHex(0x667eea);
                    });
                    renderer.domElement.style.cursor = 'default';
                }
            });

            // Mouse wheel zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const delta = e.deltaY > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;

                // Clamp camera position between 1 and 20
                const newZ = camera.position.z * delta;
                camera.position.z = Math.max(1, Math.min(20, newZ));
            }, { passive: false });

            // Animation loop
            animate();

            document.getElementById('loading').style.display = 'none';
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Auto-rotation disabled - only manual rotation via mouse drag

            renderer.render(scene, camera);
        }

        function updateMousePosition(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function highlightHoveredFace() {
            // Reset all face colors
            faceObjects.forEach(obj => {
                obj.material.color.setHex(0x667eea);
                obj.material.opacity = 0.7;
            });

            // Find intersected face
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(faceObjects, true);

            if (intersects.length > 0) {
                // Highlight the hovered face
                intersects[0].object.material.color.setHex(0xe74c3c);
                intersects[0].object.material.opacity = 0.9;
                renderer.domElement.style.cursor = 'pointer';
            } else {
                renderer.domElement.style.cursor = 'default';
            }
        }

        function handleFaceClick() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(faceObjects, true);

            if (intersects.length > 0 && currentPolyhedron) {
                const clickedFace = intersects[0].object;
                const faceIndex = faceObjects.indexOf(clickedFace);

                if (faceIndex !== -1) {
                    // Remove the face from the polyhedron data
                    currentPolyhedron.faces.splice(faceIndex, 1);

                    // Re-render the polyhedron
                    displayPolyhedron(currentPolyhedron, currentNotation);
                    updateInfo(currentPolyhedron, currentNotation);

                    console.log(`Removed face ${faceIndex}. Remaining faces: ${currentPolyhedron.faces.length}`);
                }
            }
        }

        function highlightHoveredVertex() {
            if (!vertexSpheresGroup) return;

            // Reset all vertex colors
            vertexSpheresGroup.children.forEach(sphere => {
                sphere.material.color.setHex(0x667eea);
                sphere.material.emissive.setHex(0x667eea);
            });

            // Find intersected vertex
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(vertexSpheresGroup.children, true);

            if (intersects.length > 0) {
                // Highlight the hovered vertex
                intersects[0].object.material.color.setHex(0xe74c3c);
                intersects[0].object.material.emissive.setHex(0xe74c3c);
                renderer.domElement.style.cursor = 'pointer';
            } else {
                renderer.domElement.style.cursor = 'default';
            }
        }

        function handleVertexClick() {
            if (!vertexSpheresGroup || !currentPolyhedron) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(vertexSpheresGroup.children, true);

            if (intersects.length > 0) {
                const clickedSphere = intersects[0].object;
                const vertexIndex = clickedSphere.userData.vertexIndex;

                if (vertexIndex !== undefined) {
                    // Save current state before modification
                    saveStateForUndo();

                    // Remove the vertex from all faces (instead of removing entire faces)
                    // This keeps other vertices intact when removing subdivision vertices
                    currentPolyhedron.faces = currentPolyhedron.faces.map(face => {
                        return face.filter(vIdx => vIdx !== vertexIndex);
                    }).filter(face => face.length >= 3); // Keep only valid faces (3+ vertices)

                    // Re-render the polyhedron
                    displayPolyhedron(currentPolyhedron, currentNotation);
                    updateInfo(currentPolyhedron, currentNotation);
                    updateUndoRedoButtons();

                    console.log(`Removed vertex ${vertexIndex}. Remaining faces: ${currentPolyhedron.faces.length}`);
                }
            }
        }

        // Save current polyhedron state for undo
        function saveStateForUndo() {
            if (!currentPolyhedron) return;

            // Deep copy the current state
            const state = {
                vertices: JSON.parse(JSON.stringify(currentPolyhedron.vertices)),
                faces: JSON.parse(JSON.stringify(currentPolyhedron.faces)),
                name: currentPolyhedron.name
            };

            undoStack.push(state);

            // Limit history to MAX_HISTORY
            if (undoStack.length > MAX_HISTORY) {
                undoStack.shift();
            }

            // Clear redo stack when new action is performed
            redoStack = [];
        }

        // Undo last vertex removal
        function undoVertexRemoval() {
            if (undoStack.length === 0 || !currentPolyhedron) return;

            // Save current state to redo stack
            const currentState = {
                vertices: JSON.parse(JSON.stringify(currentPolyhedron.vertices)),
                faces: JSON.parse(JSON.stringify(currentPolyhedron.faces)),
                name: currentPolyhedron.name
            };
            redoStack.push(currentState);

            // Limit redo history
            if (redoStack.length > MAX_HISTORY) {
                redoStack.shift();
            }

            // Restore previous state
            const previousState = undoStack.pop();
            currentPolyhedron.vertices = previousState.vertices;
            currentPolyhedron.faces = previousState.faces;
            currentPolyhedron.name = previousState.name;

            // Re-render
            displayPolyhedron(currentPolyhedron, currentNotation);
            updateInfo(currentPolyhedron, currentNotation);
            updateUndoRedoButtons();

            console.log('Undo: Restored previous state');
        }

        // Redo last undone vertex removal
        function redoVertexRemoval() {
            if (redoStack.length === 0 || !currentPolyhedron) return;

            // Save current state to undo stack
            const currentState = {
                vertices: JSON.parse(JSON.stringify(currentPolyhedron.vertices)),
                faces: JSON.parse(JSON.stringify(currentPolyhedron.faces)),
                name: currentPolyhedron.name
            };
            undoStack.push(currentState);

            // Restore redo state
            const redoState = redoStack.pop();
            currentPolyhedron.vertices = redoState.vertices;
            currentPolyhedron.faces = redoState.faces;
            currentPolyhedron.name = redoState.name;

            // Re-render
            displayPolyhedron(currentPolyhedron, currentNotation);
            updateInfo(currentPolyhedron, currentNotation);
            updateUndoRedoButtons();

            console.log('Redo: Restored next state');
        }

        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-vertex');
            const redoBtn = document.getElementById('redo-vertex');

            if (undoBtn) {
                undoBtn.disabled = undoStack.length === 0;
                undoBtn.title = `Undo (${undoStack.length}/${MAX_HISTORY})`;
            }
            if (redoBtn) {
                redoBtn.disabled = redoStack.length === 0;
                redoBtn.title = `Redo (${redoStack.length}/${MAX_HISTORY})`;
            }
        }

        // Clear history when generating new polyhedron
        function clearHistory() {
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
        }

        // Animation playback functions
        function startAnimation(type) {
            if (!currentPolyhedron) {
                alert('Please generate a polyhedron first');
                return;
            }

            // Stop any existing animation
            stopAnimation();

            // Reset to skyc coordinate view (Z-up as vertical, like Skybrush)
            // Rotate -90¬∞ around X to make Z point up, then tilt slightly for 3D perspective
            const skybrushRotationX = -Math.PI / 2 + Math.PI / 8; // Z-up with slight tilt
            const skybrushRotationY = Math.PI / 8; // Slight side angle

            if (polyhedronMesh) {
                polyhedronMesh.rotation.set(skybrushRotationX, skybrushRotationY, 0);
            }
            if (edgesMesh) {
                edgesMesh.rotation.set(skybrushRotationX, skybrushRotationY, 0);
            }
            if (vertexSpheresGroup) {
                vertexSpheresGroup.rotation.set(skybrushRotationX, skybrushRotationY, 0);
            }
            faceObjects.forEach(face => {
                face.rotation.set(skybrushRotationX, skybrushRotationY, 0);
            });

            // Store original vertices
            originalVertices = currentPolyhedron.vertices.map(v => [...v]);
            currentAnimationType = type;
            animationStartTime = performance.now();

            // Get settings
            const duration = parseFloat(document.getElementById('animation-duration').value) || 30;
            const rotationSpeed = parseFloat(document.getElementById('rotation-speed').value) || 4;
            const shrinkSpeed = parseFloat(document.getElementById('shrink-speed').value) || 2;
            const scaleStart = parseFloat(document.getElementById('scale-start').value) || 1;
            const scaleEnd = parseFloat(document.getElementById('scale-end').value) || 0.1;

            // Calculate center of polyhedron (XY for rotation, Z for scaling)
            let centerX = 0, centerY = 0, centerZ = 0;
            originalVertices.forEach(v => {
                centerX += v[0];
                centerY += v[1];
                centerZ += v[2];
            });
            centerX /= originalVertices.length;
            centerY /= originalVertices.length;
            centerZ /= originalVertices.length;

            // Calculate max Z offset from center for shrink speed calculation
            const maxZOffset = Math.max(...originalVertices.map(v => Math.abs(v[2] - centerZ)));
            const totalZChange = maxZOffset * Math.abs(scaleStart - scaleEnd);
            const shrinkDuration = totalZChange > 0 ? totalZChange / shrinkSpeed : duration;

            // Calculate initial angles, radii, and Z offsets
            const vertexData = originalVertices.map(v => {
                const dx = v[0] - centerX;
                const dy = v[1] - centerY;
                const zOffset = v[2] - centerZ; // Offset from Z center
                const radius = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                const omega = radius > 0.01 ? rotationSpeed / radius : 0;
                return { x: v[0], y: v[1], z: v[2], dx, dy, zOffset, radius, angle, omega };
            });

            // Use appropriate duration based on animation type
            const effectiveDuration = (type === 'shrink') ? shrinkDuration :
                                      (type === 'combined') ? Math.max(duration, shrinkDuration) : duration;

            // Update buttons
            updateAnimationButtons(type, true);

            // Animation loop
            function animateFrame() {
                const elapsed = (performance.now() - animationStartTime) / 1000;
                const t = Math.min(elapsed / effectiveDuration, 1);

                // Calculate current vertical scale (for shrink/expand - from both sides towards center)
                let verticalScale = 1;
                if (type === 'shrink' || type === 'combined') {
                    const shrinkT = Math.min(elapsed / shrinkDuration, 1);
                    verticalScale = scaleStart + (scaleEnd - scaleStart) * shrinkT;
                }

                // Update vertices
                for (let i = 0; i < currentPolyhedron.vertices.length; i++) {
                    const data = vertexData[i];
                    let newX, newY, newZ;

                    if (type === 'rotate' || type === 'combined') {
                        // Rotate around Z axis (same as skyc export)
                        const angle = data.angle + data.omega * elapsed;
                        newX = centerX + data.radius * Math.cos(angle);
                        newY = centerY + data.radius * Math.sin(angle);
                    } else {
                        // Keep original X, Y
                        newX = data.x;
                        newY = data.y;
                    }

                    // Scale Z from center (same as skyc export - shrinks from both sides)
                    // z = centerZ + zOffset * scale
                    newZ = centerZ + data.zOffset * verticalScale;

                    currentPolyhedron.vertices[i] = [newX, newY, newZ];
                }

                // Re-render
                displayPolyhedron(currentPolyhedron, currentNotation);

                // Continue or loop
                if (t < 1) {
                    animationId = requestAnimationFrame(animateFrame);
                } else {
                    // Loop the animation
                    animationStartTime = performance.now();
                    animationId = requestAnimationFrame(animateFrame);
                }
            }

            animationId = requestAnimationFrame(animateFrame);
        }

        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            // Restore original vertices
            if (originalVertices && currentPolyhedron) {
                currentPolyhedron.vertices = originalVertices.map(v => [...v]);
                displayPolyhedron(currentPolyhedron, currentNotation);
            }

            originalVertices = null;
            updateAnimationButtons(currentAnimationType, false);
            currentAnimationType = null;
        }

        function updateAnimationButtons(type, isPlaying) {
            const types = ['rotate', 'shrink', 'combined'];
            types.forEach(t => {
                const playBtn = document.getElementById(`play-${t}`);
                const stopBtn = document.getElementById(`stop-${t}`);
                if (playBtn && stopBtn) {
                    if (isPlaying && t === type) {
                        playBtn.disabled = true;
                        stopBtn.disabled = false;
                    } else {
                        playBtn.disabled = isPlaying;
                        stopBtn.disabled = true;
                    }
                }
            });
        }

        async function exportAnimation(type) {
            if (!currentPolyhedron) {
                alert('Please generate a polyhedron first');
                return;
            }

            // Stop any playing animation first
            stopAnimation();

            const duration = parseFloat(document.getElementById('animation-duration').value) || 30;
            const rotationSpeed = parseFloat(document.getElementById('rotation-speed').value) || 4;
            const shrinkSpeed = parseFloat(document.getElementById('shrink-speed').value) || 2;
            const scaleStart = parseFloat(document.getElementById('scale-start').value) || 1;
            const scaleEnd = parseFloat(document.getElementById('scale-end').value) || 0.1;
            const xyMin = parseFloat(document.getElementById('xy-min').value) || -50;
            const xyMax = parseFloat(document.getElementById('xy-max').value) || 50;
            const zMin = parseFloat(document.getElementById('z-min').value) || 0;
            const zMax = parseFloat(document.getElementById('z-max').value) || 100;

            // Get only the used vertices with Z scale applied
            const usedVertices = getUsedVertices(currentPolyhedron);
            const usedVertexArray = Array.from(usedVertices).sort((a, b) => a - b);

            // Create mapping from old index to new index
            const indexMap = new Map();
            usedVertexArray.forEach((oldIdx, newIdx) => {
                indexMap.set(oldIdx, newIdx);
            });

            const vertices = usedVertexArray.map(idx => {
                const v = currentPolyhedron.vertices[idx];
                return [v[0], v[1], v[2] * zScale];
            });

            // Remap faces to use new vertex indices
            const faces = currentPolyhedron.faces.map(face => {
                return face.map(vIdx => indexMap.get(vIdx));
            }).filter(face => face.every(idx => idx !== undefined));

            if (vertices.length === 0) {
                alert('No vertices to export');
                return;
            }

            // Generate filename based on notation and animation type
            const filename = `${currentNotation}_${type}.skyc`;

            // Build export data
            const exportData = {
                vertices,
                faces,
                filename,
                animation: {
                    enableRotation: type === 'rotate' || type === 'combined',
                    rotationSpeed,
                    enableScale: type === 'shrink' || type === 'combined',
                    shrinkSpeed,
                    scaleStart,
                    scaleEnd,
                    duration,
                    fps: 25
                },
                bounds: { targetEdgeLength: 4, altitudeOffset: 15 }
            };

            try {
                const response = await fetch('/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(exportData)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Export failed');
                }

                const result = await response.json();
                alert(`Success!\n\n${result.message}\n\nAnimation: ${type}\nFile: ${result.filename}`);
            } catch (error) {
                console.error('Export error:', error);
                alert(`Export failed: ${error.message}`);
            }
        }

        function subdivideEdges() {
            if (!currentPolyhedron) return;

            console.log('Subdividing edges...');

            const oldVertices = currentPolyhedron.vertices;
            const oldFaces = currentPolyhedron.faces;

            // New vertices and faces
            const newVertices = [...oldVertices];
            const newFaces = [];

            // For each face, subdivide it
            oldFaces.forEach(face => {
                const faceVertexCount = face.length;

                // Calculate face center
                const centerVertex = [0, 0, 0];
                face.forEach(vIdx => {
                    const v = oldVertices[vIdx];
                    centerVertex[0] += v[0];
                    centerVertex[1] += v[1];
                    centerVertex[2] += v[2];
                });
                centerVertex[0] /= faceVertexCount;
                centerVertex[1] /= faceVertexCount;
                centerVertex[2] /= faceVertexCount;

                const centerIdx = newVertices.length;
                newVertices.push(centerVertex);

                // Add midpoint vertices for each edge and create new faces
                const midpointIndices = [];
                for (let i = 0; i < faceVertexCount; i++) {
                    const v1Idx = face[i];
                    const v2Idx = face[(i + 1) % faceVertexCount];
                    const v1 = oldVertices[v1Idx];
                    const v2 = oldVertices[v2Idx];

                    // Calculate midpoint
                    const midpoint = [
                        (v1[0] + v2[0]) / 2,
                        (v1[1] + v2[1]) / 2,
                        (v1[2] + v2[2]) / 2
                    ];

                    const midpointIdx = newVertices.length;
                    newVertices.push(midpoint);
                    midpointIndices.push(midpointIdx);
                }

                // Create new quads for each edge
                for (let i = 0; i < faceVertexCount; i++) {
                    const vIdx = face[i];
                    const midpoint1Idx = midpointIndices[i];
                    const midpoint2Idx = midpointIndices[(i - 1 + faceVertexCount) % faceVertexCount];

                    // Create quad: original vertex -> midpoint1 -> center -> midpoint2
                    newFaces.push([vIdx, midpoint1Idx, centerIdx, midpoint2Idx]);
                }
            });

            // Update polyhedron
            currentPolyhedron.vertices = newVertices;
            currentPolyhedron.faces = newFaces;

            console.log(`Subdivision complete. New vertices: ${newVertices.length}, New faces: ${newFaces.length}`);

            // Re-render
            displayPolyhedron(currentPolyhedron, currentNotation);
            updateInfo(currentPolyhedron, currentNotation);
        }

        async function generatePolyhedron(notation) {
            try {
                // Clear previous error
                document.getElementById('error-message').innerHTML = '';

                // Disable button during generation
                const button = document.getElementById('generate');
                button.disabled = true;
                button.textContent = 'Generating...';

                // Call the server API
                const response = await fetch('/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ notation })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to generate polyhedron');
                }

                const poly = await response.json();
                currentPolyhedron = poly;
                currentNotation = notation;

                // Stop any playing animation and clear history
                stopAnimation();
                clearHistory();

                // Update display
                displayPolyhedron(poly, notation);
                updateInfo(poly, notation);

                button.disabled = false;
                button.textContent = 'Generate';

            } catch (error) {
                console.error('Error generating polyhedron:', error);
                document.getElementById('error-message').innerHTML =
                    `<div class="error">Error: ${error.message}</div>`;

                const button = document.getElementById('generate');
                button.disabled = false;
                button.textContent = 'Generate';
            }
        }

        function getUsedVertices(poly) {
            // Find all vertices that are referenced by faces
            const usedVertices = new Set();
            poly.faces.forEach(face => {
                face.forEach(vertexIndex => {
                    usedVertices.add(vertexIndex);
                });
            });
            return usedVertices;
        }

        // Polygon type names
        const POLYGON_NAMES = {
            3: 'Triangle',
            4: 'Quadrilateral',
            5: 'Pentagon',
            6: 'Hexagon',
            7: 'Heptagon',
            8: 'Octagon',
            9: 'Nonagon',
            10: 'Decagon',
            11: 'Hendecagon',
            12: 'Dodecagon'
        };

        function getPolygonName(sides) {
            return POLYGON_NAMES[sides] || `${sides}-gon`;
        }

        function getPolygonSignature(poly, face) {
            // Calculate edge lengths for the face
            const edgeLengths = [];
            for (let i = 0; i < face.length; i++) {
                const v1 = poly.vertices[face[i]];
                const v2 = poly.vertices[face[(i + 1) % face.length]];
                const dx = v2[0] - v1[0];
                const dy = v2[1] - v1[1];
                const dz = v2[2] - v1[2];
                const length = Math.sqrt(dx * dx + dy * dy + dz * dz);
                edgeLengths.push(Math.round(length * 1000) / 1000); // Round to 3 decimals
            }
            // Sort to create a normalized signature
            return edgeLengths.sort((a, b) => a - b).join(',');
        }

        function analyzePolygonTypes(poly) {
            // Group faces by number of sides AND shape signature
            const typesBySignature = {};

            poly.faces.forEach((face, index) => {
                const sides = face.length;
                const signature = getPolygonSignature(poly, face);
                const key = `${sides}:${signature}`;

                if (!typesBySignature[key]) {
                    typesBySignature[key] = {
                        sides: sides,
                        signature: signature,
                        count: 0,
                        faceIndices: [],
                        vertexIndices: new Set()
                    };
                }
                typesBySignature[key].count++;
                typesBySignature[key].faceIndices.push(index);
                face.forEach(vIdx => typesBySignature[key].vertexIndices.add(vIdx));
            });

            // Group by number of sides to assign variant numbers
            const sideGroups = {};
            Object.keys(typesBySignature).forEach(key => {
                const type = typesBySignature[key];
                if (!sideGroups[type.sides]) {
                    sideGroups[type.sides] = [];
                }
                sideGroups[type.sides].push({ key, ...type });
            });

            // Assign variant numbers and build final result
            const result = {};
            Object.keys(sideGroups).forEach(sides => {
                const variants = sideGroups[sides];
                // Sort variants by count (descending) for consistent ordering
                variants.sort((a, b) => b.count - a.count);

                variants.forEach((variant, idx) => {
                    const variantNum = variants.length > 1 ? idx + 1 : 0;
                    result[variant.key] = {
                        sides: variant.sides,
                        variantNum: variantNum,
                        totalVariants: variants.length,
                        count: variant.count,
                        faceIndices: variant.faceIndices,
                        vertexIndices: variant.vertexIndices
                    };
                });
            });

            return result;
        }

        function drawPolygonShape(canvas, sides) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 2 - 4;

            ctx.clearRect(0, 0, width, height);

            // Draw the polygon
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                // Start from top (-PI/2) and go clockwise
                const angle = (2 * Math.PI * i / sides) - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();

            // Fill with gradient
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');
            ctx.fillStyle = gradient;
            ctx.fill();

            // Stroke
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function removePolygonsByType(typeKey) {
            if (!currentPolyhedron) return;

            // Save state for undo
            saveStateForUndo();

            // Get the polygon type info
            const types = analyzePolygonTypes(currentPolyhedron);
            const typeInfo = types[typeKey];

            if (!typeInfo) return;

            // Get vertices to remove from this specific polygon type
            const verticesToRemove = typeInfo.vertexIndices;

            // Remove all faces that contain any of these vertices
            currentPolyhedron.faces = currentPolyhedron.faces.filter(face => {
                // Keep face only if none of its vertices are in the removal set
                return !face.some(vIdx => verticesToRemove.has(vIdx));
            });

            // Re-display the polyhedron
            displayPolyhedron(currentPolyhedron, currentNotation);
            updateInfo(currentPolyhedron, currentNotation);
            updateUndoRedoButtons();
        }

        function removeHalfPolygonsByType(typeKey) {
            if (!currentPolyhedron) return;

            // Save state for undo
            saveStateForUndo();

            // Get the polygon type info
            const types = analyzePolygonTypes(currentPolyhedron);
            const typeInfo = types[typeKey];

            if (!typeInfo || typeInfo.count < 2) return;

            // Calculate center of each face
            const faceCenters = typeInfo.faceIndices.map(faceIdx => {
                const face = currentPolyhedron.faces[faceIdx];
                let cx = 0, cy = 0, cz = 0;
                face.forEach(vIdx => {
                    const v = currentPolyhedron.vertices[vIdx];
                    cx += v[0];
                    cy += v[1];
                    cz += v[2];
                });
                return {
                    faceIdx,
                    center: [cx / face.length, cy / face.length, cz / face.length]
                };
            });

            // Find symmetrical pairs (center1 ‚âà -center2)
            const tolerance = 0.01;
            const paired = new Set();
            const pairs = [];

            for (let i = 0; i < faceCenters.length; i++) {
                if (paired.has(i)) continue;

                const c1 = faceCenters[i].center;

                for (let j = i + 1; j < faceCenters.length; j++) {
                    if (paired.has(j)) continue;

                    const c2 = faceCenters[j].center;

                    // Check if c2 ‚âà -c1 (symmetric around origin)
                    const dx = Math.abs(c1[0] + c2[0]);
                    const dy = Math.abs(c1[1] + c2[1]);
                    const dz = Math.abs(c1[2] + c2[2]);

                    if (dx < tolerance && dy < tolerance && dz < tolerance) {
                        pairs.push([faceCenters[i].faceIdx, faceCenters[j].faceIdx]);
                        paired.add(i);
                        paired.add(j);
                        break;
                    }
                }
            }

            // Remove pairs until we've removed about half
            const pairsToRemove = Math.ceil(pairs.length / 2);
            const faceIndicesToRemove = new Set();

            for (let i = 0; i < pairsToRemove && i < pairs.length; i++) {
                faceIndicesToRemove.add(pairs[i][0]);
                faceIndicesToRemove.add(pairs[i][1]);
            }

            // If we couldn't find enough pairs, fall back to removing unpaired faces
            if (faceIndicesToRemove.size === 0 && typeInfo.count >= 2) {
                // Fallback: remove every other face
                typeInfo.faceIndices.forEach((faceIdx, i) => {
                    if (i % 2 === 1) {
                        faceIndicesToRemove.add(faceIdx);
                    }
                });
            }

            // Collect ALL vertices from faces being removed
            const verticesToRemove = new Set();
            faceIndicesToRemove.forEach(faceIdx => {
                currentPolyhedron.faces[faceIdx].forEach(vIdx => {
                    verticesToRemove.add(vIdx);
                });
            });

            // Remove ALL faces that contain any of these vertices
            currentPolyhedron.faces = currentPolyhedron.faces.filter(face => {
                return !face.some(vIdx => verticesToRemove.has(vIdx));
            });

            // Re-display the polyhedron
            displayPolyhedron(currentPolyhedron, currentNotation);
            updateInfo(currentPolyhedron, currentNotation);
            updateUndoRedoButtons();
        }

        function updatePolygonTypesDisplay(poly) {
            const container = document.getElementById('polygon-types-container');
            const types = analyzePolygonTypes(poly);
            const typeKeys = Object.keys(types);

            if (typeKeys.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 13px;">No faces remaining</div>';
                return;
            }

            // Sort by sides first, then by variant number
            typeKeys.sort((a, b) => {
                const sidesA = types[a].sides;
                const sidesB = types[b].sides;
                if (sidesA !== sidesB) return sidesA - sidesB;
                return types[a].variantNum - types[b].variantNum;
            });

            let html = '';
            typeKeys.forEach(key => {
                const typeInfo = types[key];
                const baseName = getPolygonName(typeInfo.sides);
                // Add variant number if there are multiple variants of this polygon type
                const name = typeInfo.variantNum > 0 ? `${baseName} ${typeInfo.variantNum}` : baseName;
                const canvasId = `polygon-canvas-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
                const escapedKey = key.replace(/'/g, "\\'");

                html += `
                    <div class="polygon-type-card">
                        <canvas id="${canvasId}" class="polygon-canvas" width="50" height="50"></canvas>
                        <div class="polygon-info">
                            <div class="polygon-name">${name}</div>
                            <div class="polygon-count">${typeInfo.count} face${typeInfo.count !== 1 ? 's' : ''}</div>
                        </div>
                        <div class="polygon-buttons">
                            <button class="remove-half-btn" onclick="removeHalfPolygonsByType('${escapedKey}')"
                                    ${typeInfo.count < 2 ? 'disabled title="Need at least 2 faces"' : ''}>
                                Remove Half
                            </button>
                            <button class="remove-polygon-btn" onclick="removePolygonsByType('${escapedKey}')"
                                    ${typeKeys.length <= 1 ? 'disabled title="Cannot remove last polygon type"' : ''}>
                                Remove All
                            </button>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;

            // Draw polygon shapes on canvases
            typeKeys.forEach(key => {
                const canvasId = `polygon-canvas-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
                const canvas = document.getElementById(canvasId);
                if (canvas) {
                    drawPolygonShape(canvas, types[key].sides);
                }
            });
        }

        function createVertexSpheres(poly, center, scale) {
            // Get only vertices that are used by faces
            const usedVertices = getUsedVertices(poly);

            // Create a group to hold all vertex spheres
            vertexSpheresGroup = new THREE.Group();
            vertexSphereMap.clear();

            // Create glowing sphere geometry (shared)
            const sphereGeometry = new THREE.SphereGeometry(0.05, 16, 16);

            // Create glowing white material
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.8,
                roughness: 0.3,
                metalness: 0.5
            });

            usedVertices.forEach(vIdx => {
                const v = poly.vertices[vIdx];
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial.clone());

                // Position the sphere at the vertex location with Z scale applied
                sphere.position.set(v[0], v[1], v[2] * zScale);
                sphere.position.sub(center);
                sphere.position.multiplyScalar(scale);

                // Store vertex index in userData for later identification
                sphere.userData.vertexIndex = vIdx;

                vertexSpheresGroup.add(sphere);
                vertexSphereMap.set(vIdx, sphere);
            });

            scene.add(vertexSpheresGroup);
        }

        function displayPolyhedron(poly, notation) {
            // Preserve current rotation if any object exists
            let savedRotation = null;
            if (polyhedronMesh) {
                savedRotation = {
                    x: polyhedronMesh.rotation.x,
                    y: polyhedronMesh.rotation.y,
                    z: polyhedronMesh.rotation.z
                };
            } else if (vertexSpheresGroup) {
                savedRotation = {
                    x: vertexSpheresGroup.rotation.x,
                    y: vertexSpheresGroup.rotation.y,
                    z: vertexSpheresGroup.rotation.z
                };
            }

            // Remove previous meshes
            if (polyhedronMesh) {
                scene.remove(polyhedronMesh);
                polyhedronMesh.geometry.dispose();
                polyhedronMesh.material.dispose();
            }
            if (edgesMesh) {
                scene.remove(edgesMesh);
                edgesMesh.geometry.dispose();
                edgesMesh.material.dispose();
            }
            // Remove all face objects
            faceObjects.forEach(obj => {
                scene.remove(obj);
                obj.geometry.dispose();
                obj.material.dispose();
            });
            faceObjects = [];

            // Remove vertex spheres group
            if (vertexSpheresGroup) {
                vertexSpheresGroup.children.forEach(sphere => {
                    sphere.geometry.dispose();
                    sphere.material.dispose();
                });
                scene.remove(vertexSpheresGroup);
                vertexSpheresGroup = null;
            }

            // Create geometry
            const geometry = new THREE.BufferGeometry();

            // Vertices with Z scale applied
            const vertices = [];
            poly.vertices.forEach(v => {
                vertices.push(v[0], v[1], v[2] * zScale);
            });
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            // Calculate center and scale for positioning
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            const size = new THREE.Vector3();
            geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 3 / maxDim;

            if (viewMode === 'vertices') {
                // VERTICES ONLY MODE
                // Create glowing spheres for vertices
                createVertexSpheres(poly, center, scale);

                // No mesh or edges in vertices-only mode
                polyhedronMesh = null;
                edgesMesh = null;

            } else {
                // FULL POLYHEDRON MODE
                // Faces indices for rendering (still need triangulation for mesh rendering)
                const indices = [];
                poly.faces.forEach(face => {
                    // Triangulate face
                    for (let i = 1; i < face.length - 1; i++) {
                        indices.push(face[0], face[i], face[i + 1]);
                    }
                });
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                // Create main mesh (semi-transparent or invisible)
                const material = new THREE.MeshPhongMaterial({
                    color: 0x667eea,
                    shininess: 100,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });

                polyhedronMesh = new THREE.Mesh(geometry, material);
                scene.add(polyhedronMesh);

                // Create edges based on actual face polygons (not triangulated) with Z scale
                const edgeVertices = [];
                poly.faces.forEach(face => {
                    // Draw edges around the actual polygon
                    for (let i = 0; i < face.length; i++) {
                        const v1 = poly.vertices[face[i]];
                        const v2 = poly.vertices[face[(i + 1) % face.length]];
                        edgeVertices.push(v1[0], v1[1], v1[2] * zScale);
                        edgeVertices.push(v2[0], v2[1], v2[2] * zScale);
                    }
                });

                const edgesGeometry = new THREE.BufferGeometry();
                edgesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(edgeVertices, 3));
                const edgesMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                edgesMesh = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                scene.add(edgesMesh);

                // Position and scale both
                polyhedronMesh.position.sub(center);
                polyhedronMesh.scale.set(scale, scale, scale);
                edgesMesh.position.sub(center);
                edgesMesh.scale.set(scale, scale, scale);

                // Create individual face objects for raycasting (only in full mode)
                poly.faces.forEach((face, idx) => {
                    const faceGeometry = new THREE.BufferGeometry();
                    const faceVertices = [];

                    face.forEach(vIdx => {
                        const v = poly.vertices[vIdx];
                        faceVertices.push(v[0], v[1], v[2] * zScale);
                    });

                    faceGeometry.setAttribute('position', new THREE.Float32BufferAttribute(faceVertices, 3));

                    // Triangulate for the individual face
                    const faceIndices = [];
                    for (let i = 1; i < face.length - 1; i++) {
                        faceIndices.push(0, i, i + 1);
                    }
                    faceGeometry.setIndex(faceIndices);
                    faceGeometry.computeVertexNormals();

                    const faceMaterial = new THREE.MeshBasicMaterial({
                        color: 0x667eea,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.7
                    });

                    const faceMesh = new THREE.Mesh(faceGeometry, faceMaterial);
                    faceMesh.position.sub(center);
                    faceMesh.scale.set(scale, scale, scale);

                    // Make face mesh invisible but still raycastable
                    faceMesh.visible = false;

                    scene.add(faceMesh);
                    faceObjects.push(faceMesh);
                });

                // Create glowing spheres for vertices in full mode too
                createVertexSpheres(poly, center, scale);
            }

            // Restore rotation if we had a previous rotation
            if (savedRotation) {
                if (polyhedronMesh) {
                    polyhedronMesh.rotation.set(savedRotation.x, savedRotation.y, savedRotation.z);
                }
                if (edgesMesh) {
                    edgesMesh.rotation.set(savedRotation.x, savedRotation.y, savedRotation.z);
                }
                faceObjects.forEach(obj => {
                    obj.rotation.set(savedRotation.x, savedRotation.y, savedRotation.z);
                });
                if (vertexSpheresGroup) {
                    vertexSpheresGroup.rotation.set(savedRotation.x, savedRotation.y, savedRotation.z);
                }
            }
        }

        function updateInfo(poly, notation) {
            document.getElementById('poly-name').textContent = poly.name || 'Unknown';
            document.getElementById('current-notation').textContent = notation;

            // Count only vertices that are still used by faces
            const usedVertices = getUsedVertices(poly);
            document.getElementById('vertex-count').textContent = usedVertices.size;
            document.getElementById('face-count').textContent = poly.faces.length;

            // Count unique edges
            const edgeSet = new Set();
            poly.faces.forEach(face => {
                for (let i = 0; i < face.length; i++) {
                    const v1 = face[i];
                    const v2 = face[(i + 1) % face.length];
                    // Create a unique key for the edge (smaller index first)
                    const edgeKey = v1 < v2 ? `${v1}-${v2}` : `${v2}-${v1}`;
                    edgeSet.add(edgeKey);
                }
            });
            document.getElementById('edge-count').textContent = edgeSet.size;

            // Display only used vertices
            const verticesList = document.getElementById('vertices-list');
            let html = '';
            const sortedIndices = Array.from(usedVertices).sort((a, b) => a - b);
            sortedIndices.forEach(index => {
                const vertex = poly.vertices[index];
                const [x, y, z] = vertex.map(v => v.toFixed(4));
                html += `<div class="vertex">v${index}: (${x}, ${y}, ${z})</div>`;
            });

            if (usedVertices.size === 0) {
                html = '<div class="vertex">No vertices in use</div>';
            }

            verticesList.innerHTML = html;

            // Update polygon types display
            updatePolygonTypesDisplay(poly);
        }

        function loadExample(notation) {
            document.getElementById('notation').value = notation;
            generatePolyhedron(notation);
        }

        // Event listeners
        document.getElementById('generate').addEventListener('click', () => {
            const notation = document.getElementById('notation').value.trim();
            if (notation) {
                generatePolyhedron(notation);
            }
        });

        document.getElementById('notation').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const notation = document.getElementById('notation').value.trim();
                if (notation) {
                    generatePolyhedron(notation);
                }
            }
        });

        // View mode toggle
        document.getElementById('view-vertices').addEventListener('click', () => {
            viewMode = 'vertices';
            document.getElementById('view-vertices').classList.add('active');
            document.getElementById('view-full').classList.remove('active');

            // Re-render if we have a polyhedron
            if (currentPolyhedron) {
                displayPolyhedron(currentPolyhedron, currentNotation);
            }

            // Disable remove polygon mode when switching to vertices
            if (removePolygonMode) {
                removePolygonMode = false;
                document.getElementById('remove-polygon-mode').classList.remove('active');
                document.getElementById('mode-indicator').classList.remove('active');
                renderer.domElement.style.cursor = 'default';
            }
            // Keep remove vertex mode when switching to vertices view
        });

        document.getElementById('view-full').addEventListener('click', () => {
            viewMode = 'full';
            document.getElementById('view-full').classList.add('active');
            document.getElementById('view-vertices').classList.remove('active');

            // Re-render if we have a polyhedron
            if (currentPolyhedron) {
                displayPolyhedron(currentPolyhedron, currentNotation);
            }
        });

        // Z scale slider
        document.getElementById('z-scale').addEventListener('input', (e) => {
            zScale = parseFloat(e.target.value);
            document.getElementById('z-scale-value').textContent = zScale.toFixed(1);

            // Re-render if we have a polyhedron
            if (currentPolyhedron) {
                displayPolyhedron(currentPolyhedron, currentNotation);
            }
        });

        // Remove polygon mode toggle
        document.getElementById('remove-polygon-mode').addEventListener('click', () => {
            if (viewMode !== 'full') {
                alert('Please switch to "Full Polyhedron" view to remove polygons');
                return;
            }

            removePolygonMode = !removePolygonMode;
            const button = document.getElementById('remove-polygon-mode');
            const indicator = document.getElementById('mode-indicator');

            if (removePolygonMode) {
                // Disable vertex mode if active
                if (removeVertexMode) {
                    removeVertexMode = false;
                    document.getElementById('remove-vertex-mode').classList.remove('active');
                    if (vertexSpheresGroup) {
                        vertexSpheresGroup.children.forEach(sphere => {
                            sphere.material.color.setHex(0x667eea);
                            sphere.material.emissive.setHex(0x667eea);
                        });
                    }
                }

                button.classList.add('active');
                indicator.classList.add('active');
            } else {
                button.classList.remove('active');
                indicator.classList.remove('active');
                renderer.domElement.style.cursor = 'default';

                // Reset face colors
                faceObjects.forEach(obj => {
                    obj.material.color.setHex(0x667eea);
                    obj.material.opacity = 0.7;
                });
            }
        });

        // Remove vertex mode toggle
        document.getElementById('remove-vertex-mode').addEventListener('click', () => {
            removeVertexMode = !removeVertexMode;
            const button = document.getElementById('remove-vertex-mode');
            const indicator = document.getElementById('mode-indicator');

            if (removeVertexMode) {
                // Disable polygon mode if active
                if (removePolygonMode) {
                    removePolygonMode = false;
                    document.getElementById('remove-polygon-mode').classList.remove('active');
                    faceObjects.forEach(obj => {
                        obj.material.color.setHex(0x667eea);
                        obj.material.opacity = 0.7;
                    });
                }

                button.classList.add('active');
                indicator.classList.add('active');
            } else {
                button.classList.remove('active');
                indicator.classList.remove('active');
                renderer.domElement.style.cursor = 'default';

                // Reset vertex colors
                if (vertexSpheresGroup) {
                    vertexSpheresGroup.children.forEach(sphere => {
                        sphere.material.color.setHex(0x667eea);
                        sphere.material.emissive.setHex(0x667eea);
                    });
                }
            }
        });

        // Undo/Redo buttons
        document.getElementById('undo-vertex').addEventListener('click', () => {
            undoVertexRemoval();
        });

        document.getElementById('redo-vertex').addEventListener('click', () => {
            redoVertexRemoval();
        });

        // Keyboard shortcuts for undo/redo
        document.addEventListener('keydown', (e) => {
            // Ctrl+Z or Cmd+Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoVertexRemoval();
            }
            // Ctrl+Y or Cmd+Shift+Z for redo
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redoVertexRemoval();
            }
        });

        // Animate panel
        document.getElementById('animate-btn').addEventListener('click', () => {
            document.getElementById('animate-panel').classList.toggle('active');
        });

        document.getElementById('close-animate-panel').addEventListener('click', () => {
            stopAnimation();
            document.getElementById('animate-panel').classList.remove('active');
        });

        // Play buttons
        document.getElementById('play-rotate').addEventListener('click', () => startAnimation('rotate'));
        document.getElementById('play-shrink').addEventListener('click', () => startAnimation('shrink'));
        document.getElementById('play-combined').addEventListener('click', () => startAnimation('combined'));

        // Stop buttons
        document.getElementById('stop-rotate').addEventListener('click', stopAnimation);
        document.getElementById('stop-shrink').addEventListener('click', stopAnimation);
        document.getElementById('stop-combined').addEventListener('click', stopAnimation);

        // Export buttons
        document.getElementById('export-rotate').addEventListener('click', () => exportAnimation('rotate'));
        document.getElementById('export-shrink').addEventListener('click', () => exportAnimation('shrink'));
        document.getElementById('export-combined').addEventListener('click', () => exportAnimation('combined'));

        // Subdivide edges button
        document.getElementById('subdivide-edges').addEventListener('click', () => {
            if (!currentPolyhedron) {
                alert('Please generate a polyhedron first');
                return;
            }
            subdivideEdges();
        });

        // Initialize
        window.addEventListener('load', () => {
            initScene();
            generatePolyhedron('T'); // Start with tetrahedron
        });
    </script>
</body>
</html>
